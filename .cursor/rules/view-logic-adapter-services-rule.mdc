---
alwaysApply: true
---

Got it! Here’s an English version you can drop directly into **`.cursorrules`**.

```markdown
# =========================================================

# Cursor Rules: View / Logic / Adapter / Services (VLAS)

# =========================================================

## Goal

- **View**: pure TSX + Tailwind; knows nothing about data, state, or business logic.
- **Logic** (hooks/controllers): owns state, effects, validation, sorting/filtering, async, routing decisions.
- **Services**: abstract the outside world (HTTP, Router, Storage/Analytics) behind **Port interfaces**; implementations are adapters.
- **Adapter**: wires View with Logic and Services; lives at page/route boundaries only.

## Recommended Directory Structure

- `src/components/**` – 100% presentation (pure TSX + Tailwind)
- `src/logic/**` – state/effects/validation/machines (e.g., XState)
- `src/adapters/**` – glue between View and Logic/Services
- `src/services/**` – port interfaces + adapters (fetch/router/etc)
- `src/styles/**` – @layer, cva/variants, tokens (optional)

Example:
```

src/
├─ components/dashboard/DashboardListView.tsx
├─ logic/useDashboardList.ts
├─ adapters/DashboardList.tsx
├─ services/router.service.ts
├─ services/user.service.ts
└─ services/types.ts

````

## Generation Rules (Strict)
1) **View (Presentation)**
- Do **not** use internal state/effects/memo/callback (except pure visual/DOM a11y concerns).
- No dependencies on data sources/router/storage/HTTP.
- Props must be **display values** (already formatted strings/booleans/lists) + **event callbacks** (`onXxx`).
- All formatting (numbers/dates), sort/filter/pagination happen in **Logic**; View receives ready-to-render values.
- Tailwind utilities allowed; conditional classes based **only** on props.

2) **Logic (Hook/Controller)**
- Owns React state/effects/memos/callbacks, validation, sort/filter, pagination, async loading, permissions, routing decisions.
- Calls the outside world only through **Ports** (from `services/types.ts`). (Never call `fetch`/`axios` directly.)
- **Exception**: React Router hooks (`useNavigate`, `useLocation`) can be used directly in Logic to avoid infinite re-renders caused by Port objects being recreated on every render.
- Returns: minimal, **View-ready** data/flags/handlers.
- Testable by injecting mocked Ports.

3) **Services (Ports & Adapters)**
- **Ports**: interfaces only. No framework/HTTP specifics.
- **Adapters**: concrete implementations tied to app stack (React Router/Next Router, fetch/axios, storage). Must satisfy Ports and be swappable.

4) **Adapter (Wiring)**
- Exists only at page/route boundaries.
- Performs wiring only: bind Logic to concrete Ports and pass outputs into View.
- Do **not** add business rules here.

## Naming
- View component: `PascalCase + View` (e.g., `DashboardListView.tsx`)
- Logic hook: `useFeatureName.ts` (e.g., `useDashboardList.ts`)
- Adapter: `FeatureName.tsx` (e.g., `DashboardList.tsx`)
- Port interfaces: `*Port` (e.g., `RouterPort`, `UserPort`)
- Service implementations: `*.service.ts` (e.g., `router.service.ts`)
- Domain models: `*Model`; DTOs: `*Dto`

## IO Contract
- **View Props** = display values + callbacks. No raw domain entities; Logic must adapt/format first.
- **Logic Params** = Ports (for HTTP/API), static data, options. React Router hooks (`useNavigate`, `useLocation`) are used directly in Logic, not passed as Ports. No UI types (`ReactNode`, TSX) allowed.
- **Logic Return** = minimal render-ready values (formatted strings/flags/lists/handlers).
- **Services** = satisfy Port interfaces; concrete adapters are replaceable. Port objects should be singletons to maintain referential equality.

## Common Prohibitions
- No data fetching/routing calls/`useLocation`/`useNavigate` inside **View**.
- No number/date formatting, sort/filter logic in **View**.
- No direct `fetch/axios` in **Logic** (must go through Ports).
- **Exception**: `useNavigate` and `useLocation` can be used directly in Logic hooks to prevent infinite re-renders.
- No business rules inside **Adapter**.

## Templates

### View (Pure TSX + Tailwind)
```tsx
// src/components/[feature]/[FeatureName]View.tsx
import { FC } from "react";
import { cn } from "@/utils";

type Item = { id: string; label: string };

type Props = {
  className?: string;
  titleText: string;                  // preformatted display string
  items: Item[];                      // minimal render data
  activeId?: string;                  // display-only flag
  onItemClick: (id: string) => void;  // events bubble up
};

export const [FeatureName]View: FC<Props> = ({
  className, titleText, items, activeId, onItemClick
}) => (
  <div className={cn("w-full", className)}>
    <h2 className="text-xl font-semibold">{titleText}</h2>
    <ul className="mt-3 space-y-2">
      {items.map(it => {
        const active = it.id === activeId;
        return (
          <li key={it.id}>
            <button
              type="button"
              onClick={() => onItemClick(it.id)}
              className={cn(
                "w-full rounded-md px-3 py-2 text-left",
                active ? "bg-zinc-100" : "bg-transparent"
              )}
            >
              {it.label}
            </button>
          </li>
        );
      })}
    </ul>
  </div>
);
````

### Services (Ports & Adapters)

```ts
// src/services/types.ts
export type RouterPort = {
  getPath: () => string;
  goTo: (path: string) => void;
};

export type UserPort = {
  getPoints: () => Promise<number>;
};
```

```ts
// src/services/router.service.ts (React Router adapter example)
// NOTE: RouterPort is kept for backward compatibility, but Logic hooks should
// use useNavigate/useLocation directly to avoid infinite re-renders
import { useLocation, useNavigate } from "react-router-dom";
import type { RouterPort } from "./types";

export function useRouterPort(): RouterPort {
  const nav = useNavigate();
  const loc = useLocation();
  return {
    getPath: () => loc.pathname,
    goTo: (path) => nav(path),
  };
}
```

```ts
// src/services/user.service.ts (HTTP adapter example)
import type { UserPort } from "./types";

// IMPORTANT: Use singleton pattern to prevent infinite re-renders
// Port objects should be stable references, not recreated on every call
const userPortInstance: UserPort = {
  async getPoints() {
    const res = await fetch("/api/me/points");
    const { points } = await res.json();
    return points;
  },
};

export function createUserPort(): UserPort {
  return userPortInstance; // Return same instance to maintain referential equality
}
```

### Logic (Hook/Controller)

```ts
// src/logic/use[FeatureName].ts
import { useEffect, useMemo, useState, useCallback } from "react";
import { useLocation, useNavigate } from "react-router-dom";

type MenuItemModel = { id: string; label: string; path?: string };

export function use[FeatureName](params: {
  user?: { getPoints: () => Promise<number> };
  menu: MenuItemModel[];
}) {
  const { user, menu } = params;
  const location = useLocation();
  const navigate = useNavigate();
  const [points, setPoints] = useState<number | null>(null);

  useEffect(() => {
    if (!user) return;
    let alive = true;
    user.getPoints().then(v => alive && setPoints(v));
    return () => { alive = false; };
  }, [user]);

  const titleText = useMemo(
    () => (points == null ? "—" : points.toLocaleString()),
    [points]
  );

  const items = useMemo(() => menu.map(({ id, label }) => ({ id, label })), [menu]);

  // Use location.pathname directly instead of router.getPath() to avoid re-renders
  const activeId = useMemo(() => {
    const currentPath = location.pathname;
    return menu.find(m => m.path === currentPath)?.id;
  }, [location.pathname, menu]);

  // Use navigate directly instead of router.goTo() to avoid re-renders
  const onItemClick = useCallback((id: string) => {
    const target = menu.find(m => m.id === id && m.path);
    if (target) navigate(target.path!);
  }, [navigate, menu]);

  return { titleText, items, activeId, onItemClick };
}
```

### Adapter (Wiring)

```tsx
// src/adapters/[FeatureName].tsx
import { [FeatureName]View } from "@/components/[feature]/[FeatureName]View";
import { use[FeatureName] } from "@/logic/use[FeatureName]";
import { useRouterPort } from "@/services/router.service";
import { createUserPort } from "@/services/user.service";

const MENU = [
  { id: "favorites", label: "Favorites", path: "/my-page/favorites" },
  { id: "library",   label: "Library",   path: "/my-page/library" },
  { id: "point",     label: "Points",    path: "/my-page/point" },
  { id: "main",      label: "Manage",    path: "/my-page/main" },
  { id: "revenue",   label: "Revenue",   path: "/my-page/revenue" },
];

export function [FeatureName]({ className }: { className?: string }) {
  // Port objects are singletons, safe to use as dependencies
  const user = createUserPort();
  // Logic hook uses React Router hooks directly, no router Port needed
  const { titleText, items, activeId, onItemClick } =
    use[FeatureName]({ user, menu: MENU });

  return (
    <[FeatureName]View
      className={className}
      titleText={titleText}
      items={items}
      activeId={activeId}
      onItemClick={onItemClick}
    />
  );
}
```

## Testing Guide

- **View**: a11y (roles/aria), class toggles, snapshots. No external mocks needed.
- **Logic**: inject mocked Ports to test state transitions and data shaping.
- **Services**: test adapters only in integration (with real router/network).

## Adoption Checklist

- [ ] View has **no** state/async/routing calls.
- [ ] Number/date formatting and sort/filter happen in **Logic**.
- [ ] Logic depends on **Ports** for HTTP/API calls, but uses `useNavigate`/`useLocation` directly for routing.
- [ ] Port objects are **singletons** (stable references) to prevent infinite re-renders.
- [ ] Adapter only wires; no business rules.
- [ ] New features follow the templates and naming above.

```

```
